<!doctype html>
<html lang="en">
<head>
	<title>Multiple Cameras (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>

<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>
<div id="infoButton"></div>
<div id="infoBox" title="Demo Information">
Press '1' for chase camera, '2' for top camera. <br/>
Movement controls: <br/>
<ul>
<li>W/S: Translate Forward/Backward
<li>A/D: Rotate Left/Right
<li>Q/E: Translate Left/Right
<li>R/F: Rotate Up/Down
<li>Z: Reset position and rotation.
</ul>
This three.js demo is part of a collection at
<a href="http://stemkoski.github.io/Three.js/">http://stemkoski.github.io/Three.js/</a>
</div>
<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var MovingCube, specialobj;
var colorSet = [Math.random() * 0xffffff, 0xff0000];
var rCube = 0;
var chaseCamera;
var chaseCameraActive = false;
var collidableMeshList = [];
var d = new Date()
var prevTime = d.getTime();
init();
animate();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	// camera
	chaseCamera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(chaseCamera);
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, chaseCamera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	// CONTROLS
	// MUST REMOVE THIS LINE FOR THIS DEMO.
	// controls = ...

	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	// scene.add(skyBox);
	scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
	
	////////////
	// CUSTOM //
	////////////

	var geometry = new THREE.SphereGeometry( 12, 8, 8 );
	var material = new THREE.MeshLambertMaterial( {color: 0xffff00} );
	MovingCube = new THREE.Mesh( geometry, material );
	MovingCube.position.set(0, 25.1, 0);
	scene.add( MovingCube );	
	
	// a little bit of scenery...

	var ambientlight = new THREE.AmbientLight(0x111111);
	scene.add( ambientlight );

	var geometry = new THREE.TorusKnotGeometry( 13, 3, 64, 8, 20, 5 );
	specialobj = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: Math.random() * 0xffffff } ) );
	specialobj.position.x = Math.random() * 800 - 400;
	specialobj.position.y = Math.random() * 800 - 400;
	specialobj.position.z = Math.random() * 800 - 400;
	scene.add( specialobj );
	specialobj.currentHex = specialobj.material.emissive.getHex();
	specialobj.material.emissive.setHex( 0xff0000 );
	
	geometry = new THREE.CubeGeometry( 20, 20, 20, 1, 1, 1 );
	for ( var i = 0; i < 400; i ++ ) {
		object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
		object.position.x = Math.random() * 800 - 400;
		object.position.y = Math.random() * 800 - 400;
		object.position.z = Math.random() * 800 - 400;
		object.rotation.x = Math.random() * 2 * Math.PI;
		object.rotation.y = Math.random() * 2 * Math.PI;
		object.rotation.z = Math.random() * 2 * Math.PI;
		object.scale.x = Math.random() + 0.5;
		object.scale.y = Math.random() + 0.5;
		object.scale.z = Math.random() + 0.5;
		scene.add( object );
		collidableMeshList.push(object);
	}
	
	var specialobjPoint = specialobj.position.clone();
	for (var vertexIndex = 0; vertexIndex < specialobj.geometry.vertices.length; vertexIndex++)
	{
		var localVertex = specialobj.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( specialobj.matrix );
		var directionVector = globalVertex.sub( specialobj.position );
		
		var ray = new THREE.Raycaster( specialobjPoint, directionVector.clone().normalize() );
		var collisionResults = ray.intersectObjects( collidableMeshList );
		if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
				specialobj.translateZ( 1 );
		}
	}
}

function animate() 
{
    requestAnimationFrame( animate );
	render();	
	update();
	specialobj.rotation.x += 0.01;
	specialobj.rotation.y += 0.08;
	renderer.render( scene, camera );
}

function update()
{
	/*                       // DOESNT WORK
	var currTime = new Date().getTime();
        if (prevTime != 0) {
            var elapsed = currTime - prevTime;
			rCube -= (1 * elapsed) / 100000.0;
			specialobj.rotateOnAxis(new THREE.Vector3( 1, 1, 1 ) ,rCube);
			specialobj.rotat
        }
        prevTime = currTime;
	*/
	var delta = clock.getDelta(); // seconds.
	var moveDistance = 200 * delta; // 200 pixels per second
	var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
	
	// local transformations
	//topCamera.position.set(0+MovingCube.position.x,200,550+MovingCube.position.z);
	// move forwards/backwards/left/right
	if ( keyboard.pressed("W") ){
		MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
	}
	if ( keyboard.pressed("S") ){
		MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
	}
	if ( keyboard.pressed(" ") ){
		MovingCube.translateZ(  -moveDistance );
	}
	/*
	if ( keyboard.pressed("Q") ){
		MovingCube.translateX( -moveDistance );
	}
	if ( keyboard.pressed("E") ){
		MovingCube.translateX(  moveDistance );
	*/
	// rotate left/right/up/down
	var rotation_matrix = new THREE.Matrix4().identity();
	if ( keyboard.pressed("A") )
		MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
	if ( keyboard.pressed("D") )
		MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
	
	if ( keyboard.pressed("R") )
	{
		MovingCube.translateZ(  moveDistance );
		//scene.myShape.material.color.setHex(0xff3333);
		//myShape.material.color.setHex(0x3333ff);
		//MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
	}
	/*
	if ( keyboard.pressed("F") )
		myShape.material.color.setHex(0xff0000);
	if ( keyboard.pressed("Z") )
	{
		MovingCube.position.set(0,25.1,0);
		MovingCube.rotation.set(0,0,0);
	}
	var relativeCameraOffset = new THREE.Vector3(0,50,200);

	var cameraOffset = relativeCameraOffset.applyMatrix4( MovingCube.matrixWorld );
	*/
	
	
	chaseCamera.position.x = MovingCube.position.x;
	chaseCamera.position.y = MovingCube.position.y;
	chaseCamera.position.z = MovingCube.position.z;
	chaseCamera.rotation.x = MovingCube.rotation.x;
	chaseCamera.rotation.y = MovingCube.rotation.y;
	chaseCamera.rotation.z = MovingCube.rotation.z;
	chaseCamera.translateZ(100);
	chaseCamera.translateY(10);

	var originPoint = MovingCube.position.clone();
	
	for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
	{
		var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
		var directionVector = globalVertex.sub( MovingCube.position );
		
		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		var collisionResults = ray.intersectObjects( collidableMeshList );
		if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
			if ( keyboard.pressed(" ") ){
				MovingCube.translateZ(  1 );
			}
			if ( keyboard.pressed("R") ){
				MovingCube.translateZ(  -1 );
			}
		}
		var collisionResults = ray.intersectObjects( [specialobj] );
		if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
			specialobj.position.x = Math.random() * 800 - 400;
			specialobj.position.y = Math.random() * 800 - 400;
			specialobj.position.z = Math.random() * 800 - 400;
			specialobj.material.color.setHex = Math.random() * 0xffffff;
		}
	}
	
	stats.update();
}

function render() 
{
	renderer.render( scene, chaseCamera );
/*
	if (chaseCameraActive)
	{  renderer.render( scene, chaseCamera );  }
	else
	{  renderer.render( scene, topCamera );  }
	*/
}

</script>

</body>
</html>